start taking look into pathing i.e. moving jammer. (very basic complete should talk about next steps)
https://nvlabs.github.io/sionna/rt/tutorials/Mobility.html


Observe Path documentation
https://nvlabs.github.io/sionna/rt/api/paths.html#sionna.rt.Paths
#--------------------------------------------------------------------------------------------------------#



Path Engine Func
#--------------------------------------------------------------------------------------------------------#
we need to set up some sort of path engine

start with random walk -- assume constant vel

specify starting positions
specify the length of the path
specify sampling rate

curr_pos = prev_pos + rand_offset
[x, y, 0]

for moving transmitter, be aware of .position of terrain objs
if within area of a building or other terrain object:
do something 

Return list of positions

#--------------------------------------------------------------------------------------------------------#
helper function that could call the function multiple times for the same jammer
#--------------------------------------------------------------------------------------------------------#
params:
matrix (each row is the sequence of positions of each jammer)

max dimensions would be reliant on the longest path speicified  (flag)

options for such:

1. shorter path (from end of shorter path to end of simulation, jammer remains static)
2. pad the matrix from the beginning with static movement until len(path) == len[0] - padded 0s
3. Boolean to check that all the lengths of the seuqences are equal else throw error
4. don't pad anything, when jammer ends path it's removed
#--------------------------------------------------------------------------------------------------------#



create motion engine class








Research Collision logic for buildings from open street map --- it seems that on export, objects are compartmentalized?

print(scene.get("Chicago_Water_Tower-itu_concrete").mi_mesh.bbox())

# when iterating, 

